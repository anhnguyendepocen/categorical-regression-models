<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Categorical Models" />
<meta property="og:type" content="book" />


<meta property="og:description" content="description" />
<meta name="github-repo" content="repohere" />

<meta name="author" content="Michael Clark" />

<meta name="date" content="2016-09-18" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="description">

<title>Categorical Models</title>

<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<script src="libs/htmlwidgets-0.7/htmlwidgets.js"></script>
<script src="libs/jquery-1.12.4/jquery.min.js"></script>
<script src="libs/datatables-binding-0.2/datatables.js"></script>
<link href="libs/dt-core-bootstrap-1.10.12/css/dataTables.bootstrap.min.css" rel="stylesheet" />
<link href="libs/dt-core-bootstrap-1.10.12/css/dataTables.bootstrap.extra.css" rel="stylesheet" />
<script src="libs/dt-core-bootstrap-1.10.12/js/jquery.dataTables.min.js"></script>
<script src="libs/dt-core-bootstrap-1.10.12/js/dataTables.bootstrap.min.js"></script>
<link href="libs/plotlyjs-1.10.1/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotlyjs-1.10.1/plotly-latest.min.js"></script>
<script src="libs/plotly-binding-3.6.0/plotly.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link rel="stylesheet" href="toc.css" type="text/css" />
<link rel="stylesheet" href="style_for_miles_and_miles_so_much_style_that_its_wasted.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#preface"><span class="toc-section-number">1</span> Preface</a></li>
<li><a href="2-intro.html#intro"><span class="toc-section-number">2</span> Introduction</a></li>
<li class="has-sub"><a href="3-two-categories.html#two-categories"><span class="toc-section-number">3</span> Two categories</a><ul>
<li class="has-sub"><a href="3-1-data.html#data"><span class="toc-section-number">3.1</span> Data</a><ul>
<li><a href="3-1-data.html#binomial-distribution"><span class="toc-section-number">3.1.1</span> Binomial Distribution</a></li>
</ul></li>
<li><a href="3-2-logistic-regression-model.html#logistic-regression-model"><span class="toc-section-number">3.2</span> Logistic Regression Model</a></li>
<li><a href="3-3-example.html#example"><span class="toc-section-number">3.3</span> Example</a></li>
<li class="has-sub"><a href="3-4-interpretation.html#interpretation"><span class="toc-section-number">3.4</span> Interpretation</a><ul>
<li><a href="3-4-interpretation.html#odds-ratios"><span class="toc-section-number">3.4.1</span> Odds ratios</a></li>
<li><a href="3-4-interpretation.html#predicted-probabilities"><span class="toc-section-number">3.4.2</span> Predicted probabilities</a></li>
</ul></li>
<li><a href="3-5-summary-of-standard-logistic-regression.html#summary-of-standard-logistic-regression"><span class="toc-section-number">3.5</span> Summary of Standard Logistic Regression</a></li>
<li class="has-sub"><a href="3-6-extensions.html#extensions"><span class="toc-section-number">3.6</span> Extensions</a><ul>
<li><a href="3-6-extensions.html#counts"><span class="toc-section-number">3.6.1</span> Counts</a></li>
<li><a href="3-6-extensions.html#conditional-logistic"><span class="toc-section-number">3.6.2</span> Conditional Logistic</a></li>
<li><a href="3-6-extensions.html#bradley-terry-model"><span class="toc-section-number">3.6.3</span> Bradley-Terry Model</a></li>
</ul></li>
</ul></li>
<li><a href="4-test-page.html#test-page"><span class="toc-section-number">4</span> test page</a></li>
<li><a href="references.html#references">References</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="extensions" class="section level2">
<h2><span class="header-section-number">3.6</span> Extensions</h2>
<div id="counts" class="section level3">
<h3><span class="header-section-number">3.6.1</span> Counts</h3>
<p>As noted, the binomial distribution refers to situations in which an event occurs x number of times out of some number of trials/observations. In the binary logistic regression model, the number of trials is 1, but it certainly doesn’t have to be. If it is more than 1 we can then model the proportion, and at least in R the glm function is still used with family = binomial just as before. We just specify the target variable differently, in terms of the number of times the vs. the number of times it did not.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glm</span>(<span class="kw">cbind</span>(occurrences, non-occurrences) ~<span class="st"> </span>x +<span class="st"> </span>z, <span class="dt">data=</span>mydata, <span class="dt">family=</span>binomial)</code></pre></div>
<div id="link-with-poisson" class="section level4">
<h4><span class="header-section-number">3.6.1.1</span> Link with Poisson</h4>
<p>If the occurrences are rare and/or the total number of trials is unknown, then the model is equivalent to Poisson regression. For more on this see <a href="">link</a></p>
</div>
</div>
<div id="conditional-logistic" class="section level3">
<h3><span class="header-section-number">3.6.2</span> Conditional Logistic</h3>
<p>Situations arise when there are alternative specific covariates, such that the value a covariate takes can be different for the two outcomes. This is the first step toward <em>discrete choice</em> models (a.k.a. McFadden choice model), in which there are often more than two choices (as we will see with multinomial models), and values vary with choice. The key idea is that we have strata or groups which contain both positive and negative target values. However, the model is similar.</p>
<p><span class="math display">\[ \textrm{Logit} \propto X\beta \]</span></p>
<p>The odds of the event are <em>proportional to</em> the linear combination of the covariates. This generalizes the previous logistic regression model depicted, as it can be seen as a special case.</p>
<div id="example-1" class="section level4">
<h4><span class="header-section-number">3.6.2.1</span> Example</h4>
<p>The following example regards infertility after spontaneous and induced abortion. It is a matched case-control study such that we have exactly one ‘case’, i.e. person with infertility, per two control observations[^stratum]. We will model this with covariates that regard whether or not they previously had a spontaneous or induced abortion.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">infert =<span class="st"> </span>infert %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">spontaneous =</span> <span class="kw">factor</span>(spontaneous &gt;<span class="dv">0</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&#39;No&#39;</span>,<span class="st">&#39;Yes&#39;</span>)),
         <span class="dt">induced =</span> <span class="kw">factor</span>(induced&gt;<span class="dv">0</span>, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&#39;No&#39;</span>,<span class="st">&#39;Yes&#39;</span>)))
<span class="kw">library</span>(survival)
<span class="co"># ?infert</span>
mod_logreg =<span class="st"> </span><span class="kw">glm</span>(case ~<span class="st"> </span>spontaneous +<span class="st"> </span>induced, <span class="dt">data =</span> infert, <span class="dt">family =</span> binomial)
<span class="kw">summary</span>(mod_logreg)</code></pre></div>
<pre><code>
Call:
glm(formula = case ~ spontaneous + induced, family = binomial, 
    data = infert)

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-1.3541  -0.7320  -0.5871   1.2135   1.9200  

Coefficients:
               Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)     -1.6709     0.2802  -5.964 2.46e-09 ***
spontaneousYes   1.5863     0.3037   5.223 1.76e-07 ***
inducedYes       0.4909     0.3059   1.605    0.109    
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 316.17  on 247  degrees of freedom
Residual deviance: 286.19  on 245  degrees of freedom
AIC: 292.19

Number of Fisher Scoring iterations: 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model_condlogreg =<span class="st"> </span><span class="kw">clogit</span>(case ~<span class="st"> </span>spontaneous +<span class="st"> </span>induced +<span class="st"> </span><span class="kw">strata</span>(stratum), <span class="dt">data =</span> infert)
<span class="kw">summary</span>(model_condlogreg)</code></pre></div>
<pre><code>Call:
coxph(formula = Surv(rep(1, 248L), case) ~ spontaneous + induced + 
    strata(stratum), data = infert, method = &quot;exact&quot;)

  n= 248, number of events= 83 

                 coef exp(coef) se(coef)     z Pr(&gt;|z|)    
spontaneousYes 2.1344    8.4522   0.4050 5.270 1.36e-07 ***
inducedYes     1.0926    2.9821   0.4058 2.693  0.00709 ** 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

               exp(coef) exp(-coef) lower .95 upper .95
spontaneousYes     8.452     0.1183     3.821    18.695
inducedYes         2.982     0.3353     1.346     6.606

Rsquare= 0.141   (max possible= 0.519 )
Likelihood ratio test= 37.82  on 2 df,   p=6.118e-09
Wald test            = 27.82  on 2 df,   p=9.11e-07
Score (logrank) test = 35.79  on 2 df,   p=1.694e-08</code></pre>
<p>Note that the intercept cancels out in conditional logistic regression. It could vary by group and it would still cancel (similar to so-called fixed-effects models). Also, any variable that is constant within group will similarly cancel out. This may be better understood when the (log) likelihood is expressed as follows for the case where the strata are balanced (i.e. 1:1 matching).</p>
<p><span class="math display">\[ \mathrm{L} = (X_{y=1} - X_{y=0})\beta\]</span> <span class="math display">\[ \mathcal{L} = \ln(\frac{e^L}{1+e^L})\]</span></p>
<p>As such, anything constant within a strata would simply be 0.</p>
<p>You might have noticed the call in the clogit command output, where it says <code>coxph(...)</code>. That isn’t an error, the conditional logit is equivalent to the stratified cox proportional hazards model where the survival time is simply 1 if the event is observed, or censored (1+) if not.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coxph</span>(<span class="kw">Surv</span>(<span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(infert)), case) ~<span class="st"> </span>spontaneous +<span class="st"> </span>induced +<span class="st"> </span><span class="kw">strata</span>(stratum), <span class="dt">data=</span>infert)</code></pre></div>
<pre><code>Call:
coxph(formula = Surv(rep(1, nrow(infert)), case) ~ spontaneous + 
    induced + strata(stratum), data = infert)

                coef exp(coef) se(coef)    z       p
spontaneousYes 2.134     8.452    0.405 5.27 1.4e-07
inducedYes     1.093     2.982    0.406 2.69  0.0071

Likelihood ratio test=37.8  on 2 df, p=6.12e-09
n= 248, number of events= 83 </code></pre>
<p>In the case of 1:N matching, the denominator is based on the sum of all N non-event outcomes. If X represents the covariate values for which the event occurs, and Z for those in which it does not, for each strata:</p>
<p><span class="math display">\[ \mathcal{L} = \ln(\frac{e^{X_{y=1}\beta}}{\sum_{k=1}^N e^{Z_k\beta}})\]</span></p>
</div>
</div>
<div id="bradley-terry-model" class="section level3">
<h3><span class="header-section-number">3.6.3</span> Bradley-Terry Model</h3>
<p>The Bradley-Terry model (BT henceforth) is one in which we look to model pairwise rankings. For example, if one were to choose among various brands of some product they might select between two products at a time. In the simplest case, the BT model posits the probability product <span class="math inline">\(i\)</span> is chosen over product <span class="math inline">\(j\)</span> as:</p>
<p><span class="math display">\[\pi_{i&gt;j} = \frac{\exp(\beta_i)}{\exp(\beta_i)+\exp(\beta_j)}\]</span> <span class="math display">\[\pi_{i&gt;j} = \frac{\exp(\beta_i-\beta_j)}{1+\exp(\beta_i-\beta_j)}\]</span> <span class="math display">\[\mathrm{Logit}(\pi_{i&gt;j})  = \log(\frac{\pi_{i&gt;j}}{1 - \pi_{i&gt;j}}) = \log(\frac{\pi_{i&gt;j}}{\pi_{j&gt;i}}) = \beta_i - \beta_j\]</span></p>
<p>Thus it turns out the BT model has a connection to the standard logistic model, though we’ll have to set up the data in a specific manner for comparison. We start by creating a model matrix where each column is 1 if that item is chosen, -1 if it isn’t, and zero if it is not considered. Our response in this case is simply positive values.</p>
<div id="htmlwidget-5ead821a325f1ff1a84d" style="width:400px;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-5ead821a325f1ff1a84d">{"x":{"style":"bootstrap","filter":"none","data":[[-1,1,1,1,1,1,1,1,0,0,0,0],[0,0,0,0,-1,-1,-1,-1,1,-1,-1,-1],[1,-1,-1,-1,0,0,0,0,-1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1]],"container":"<table class=\"table table-striped table-hover\">\n  <thead>\n    <tr>\n      <th>item1\u003c/th>\n      <th>item2\u003c/th>\n      <th>item3\u003c/th>\n      <th>y\u003c/th>\n    \u003c/tr>\n  \u003c/thead>\n\u003c/table>","options":{"dom":"t","pageLength":12,"columnDefs":[{"className":"dt-right","targets":[0,1,2,3]}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[10,12,25,50,100]},"selection":{"mode":"multiple","selected":null,"target":"row"}},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># glm output for comparison; no intercept; matrix columns are reordered for easier</span>
<span class="co"># comparison; item1 is the reference group and so won&#39;t have a coefficient</span>
glmmod =<span class="st"> </span><span class="kw">glm</span>(y ~<span class="st"> </span>-<span class="dv">1</span> +<span class="st"> </span>., <span class="dt">data=</span>BTdat[,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>)], <span class="dt">family=</span>binomial)  
<span class="kw">coef</span>(glmmod)</code></pre></div>
<pre><code>    item2     item3     item1 
-2.838944 -1.419472        NA </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># using logreg function in appendix;</span>
out =<span class="st"> </span><span class="kw">optim</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">3</span>), logreg, <span class="dt">X=</span><span class="kw">as.matrix</span>(BTdat[,-<span class="dv">4</span>]), <span class="dt">y=</span>BTdat$y, <span class="dt">method=</span><span class="st">&#39;BFGS&#39;</span>)
out$par                  <span class="co"># default chooses item 3 as reference</span></code></pre></div>
<pre><code>[1]  1.419472 -1.419472  0.000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">out$par[<span class="dv">2</span>:<span class="dv">3</span>]-out$par[<span class="dv">1</span>]  <span class="co"># now same as glm with item 1 as reference</span></code></pre></div>
<pre><code>[1] -2.838944 -1.419472</code></pre>
<p>Once constructed we can run the standard logistic model, and I do so with a custom function, and with the <span class="func">glm</span> function. For identification, one of the parameters must be set to zero, which glm just simply drops out. By default the <span class="func">optim</span> output settles on the third item as the reference (as would glm[^btaslogreg]).</p>
<p>For the BT model we need a different data structure, and will have a binary response where 1 represents that comparison the first comparison item was chosen. I show the first few rows here.</p>
<div id="htmlwidget-7e27dad14283c55d31d5" style="width:300px;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-7e27dad14283c55d31d5">{"x":{"style":"bootstrap","filter":"none","data":[["item1","item1","item1","item1","item1","item1","item1","item1","item2","item2","item2","item2"],["item2","item2","item2","item2","item3","item3","item3","item3","item3","item3","item3","item3"],[1,1,1,1,0,1,1,1,1,0,0,0]],"container":"<table class=\"table table-striped table-hover\">\n  <thead>\n    <tr>\n      <th>comp1\u003c/th>\n      <th>comp2\u003c/th>\n      <th>y\u003c/th>\n    \u003c/tr>\n  \u003c/thead>\n\u003c/table>","options":{"dom":"t","pageLength":6,"columnDefs":[{"className":"dt-right","targets":2}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[6,10,25,50,100]},"selection":{"mode":"multiple","selected":null,"target":"row"}},"evals":[],"jsHooks":[]}</script>
<p>The following uses the <span class="pack">BradleyTerry2</span> package and compares the results to the standard logistic both with our custom function and the glm result.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(BradleyTerry2)
btmod =<span class="st"> </span><span class="kw">BTm</span>(y, comp1, comp2, <span class="dt">data =</span> BTdat2)

<span class="co"># coefficients in the BT model are a glm binomial regression with appropriate</span>
<span class="co"># coding of the model matrix, and represent the difference in the coefficient</span>
<span class="co"># from the reference group coefficient.</span></code></pre></div>
<pre><code>         optim      glm       BT
item2 -2.83894 -2.83894 -2.83894
item3 -1.41947 -1.41947 -1.41947</code></pre>
<p>We can see that all results are the same. Once again the output parameters from the model thus tells us the coefficient <em>difference</em> from some reference group coefficient. Using the inverse logit transform tells us the probability of selecting that item relative to the reference group, but as noted previously, that transformation applied to any difference of the coefficients tells us that probability. For example, with Item 1’s parameter set to zero, the probability of choosing Item 1 vs. Item 2 is <code>plogis(0-(-2.83894))</code> 0.945, which you can confirm by applying the <span class="func">fitted</span> function to the <span class="objclass">btmod</span>.</p>
<p>Note also the BT model is generalizable to counts, just like binary logistic regression is a special case of binomial regression more generally. Also, the BT model can handle ties, and choice specific covariates, but at that point we’re in the realm of multinomial regression, so we’ll turn to that now.</p>

</div>
</div>
<!-- </div> -->
<p style="text-align: center;">
<a href="3-5-summary-of-standard-logistic-regression.html"><button class="btn btn-default">Previous</button></a>
<a href="4-test-page.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
